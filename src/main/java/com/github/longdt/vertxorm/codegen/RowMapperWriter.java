package com.github.longdt.vertxorm.codegen;

import com.squareup.javapoet.*;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.sqlclient.Row;
import io.vertx.sqlclient.data.Numeric;

import javax.annotation.processing.Filer;
import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.SourceVersion;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import java.io.IOException;
import java.nio.Buffer;
import java.time.*;
import java.util.Map;
import java.util.UUID;
import java.util.function.Function;

import static com.google.auto.common.GeneratedAnnotationSpecs.generatedAnnotationSpec;
import static com.squareup.javapoet.TypeSpec.interfaceBuilder;
import static javax.lang.model.element.Modifier.DEFAULT;
import static javax.lang.model.element.Modifier.PUBLIC;

public class RowMapperWriter {
    private static final Map<String, String> javaType2RowTypes;
    private final Filer filer;
    private final Elements elements;
    private final SourceVersion sourceVersion;
    private final Types types;

    static {
        javaType2RowTypes = Map.ofEntries(
                Map.entry(boolean.class.getCanonicalName(), "Boolean"),
                Map.entry(Boolean.class.getCanonicalName(), "Boolean"),
                Map.entry(byte.class.getCanonicalName(), "Byte"),
                Map.entry(Byte.class.getCanonicalName(), "Byte"),
                Map.entry(short.class.getCanonicalName(), "Short"),
                Map.entry(Short.class.getCanonicalName(), "Short"),
                Map.entry(int.class.getCanonicalName(), "Integer"),
                Map.entry(Integer.class.getCanonicalName(), "Integer"),
                Map.entry(long.class.getCanonicalName(), "Long"),
                Map.entry(Long.class.getCanonicalName(), "Long"),
                Map.entry(float.class.getCanonicalName(), "Float"),
                Map.entry(Float.class.getCanonicalName(), "Float"),
                Map.entry(double.class.getCanonicalName(), "Double"),
                Map.entry(Double.class.getCanonicalName(), "Double"),
                Map.entry(String.class.getCanonicalName(), "String"),
                Map.entry(UUID.class.getCanonicalName(), "UUID"),
                Map.entry(LocalDate.class.getCanonicalName(), "LocalDate"),
                Map.entry(LocalTime.class.getCanonicalName(), "LocalTime"),
                Map.entry(LocalDateTime.class.getCanonicalName(), "LocalDateTime"),
                Map.entry(OffsetTime.class.getCanonicalName(), "OffsetTime"),
                Map.entry(OffsetDateTime.class.getCanonicalName(), "OffsetDateTime"),
                Map.entry(Buffer.class.getCanonicalName(), "Buffer"),
                Map.entry(JsonObject.class.getCanonicalName(), "JsonObject"),
                Map.entry(JsonArray.class.getCanonicalName(), "JsonArray"),
                Map.entry(Object.class.getCanonicalName(), "Value"),
                Map.entry(Numeric.class.getCanonicalName(), "Numeric"));
    }

    RowMapperWriter(ProcessingEnvironment processingEnv) {
        this.filer = processingEnv.getFiler();
        this.elements = processingEnv.getElementUtils();
        this.sourceVersion = processingEnv.getSourceVersion();
        this.types = processingEnv.getTypeUtils();
    }

    void writeRowMapper(EntityDeclaration entityDeclaration) throws IOException {
        String rowMapperName = entityDeclaration.targetType().getSimpleName().toString() + Constant.ROW_MAPPER;
        TypeSpec.Builder factory =
                interfaceBuilder(rowMapperName)
                        .addOriginatingElement(entityDeclaration.targetType());
        generatedAnnotationSpec(
                elements,
                sourceVersion,
                CodeGenProcessor.class,
                "Do not edit this file")
                .ifPresent(factory::addAnnotation);
        factory.addModifiers(PUBLIC);
        addSuperinterface(factory, entityDeclaration);
        var packageName = elements.getPackageOf(entityDeclaration.targetType()).getQualifiedName().toString();
        TypeSpecBuilders.addInterfaceInstanceField(factory, ClassName.get(packageName, rowMapperName));
        addApplyMethod(factory, entityDeclaration);
        JavaFile.builder(packageName, factory.build())
                .skipJavaLangImports(true)
                .build()
                .writeTo(filer);
    }

    private void addApplyMethod(TypeSpec.Builder factory, EntityDeclaration entityDeclaration) {
        var entityTypeName = ClassName.get(entityDeclaration.targetType());
        var methodBuilder = MethodSpec.methodBuilder("apply")
                .addModifiers(DEFAULT, PUBLIC)
                .addAnnotation(Override.class)
                .addParameter(ClassName.get(Row.class), "row")
                .returns(entityTypeName)
                .addStatement("$1T entity = new $1T()", entityDeclaration.targetType());
        addMappingStatements(methodBuilder, entityDeclaration, "row");
        methodBuilder.addStatement("return entity");
        factory.addMethod(methodBuilder.build());
    }

    private void addSuperinterface(TypeSpec.Builder factory, EntityDeclaration entityDeclaration) {
        factory.addSuperinterface(ParameterizedTypeName.get(
                ClassName.get(Function.class),
                ClassName.get(Row.class),
                ClassName.get(entityDeclaration.targetType())
        ));
    }

    private void addMappingStatements(MethodSpec.Builder methodBuilder, EntityDeclaration entityDeclaration, String varName) {
        var entityTableTypeName = ClassName.bestGuess(entityDeclaration.targetType().toString() + Constant.TABLE);
        int[] i = new int[1];
        entityDeclaration.fieldStream()
                .forEach(field -> {
                    if (field.converter().isPresent()) {
                        String converterFieldName = NamingStrategies.camelToScreamSnake(AnnotationHelper.getSimpleClassName(field.converter().get()));
                        methodBuilder.addCode("entity.set$L($T.$L.convertToEntityAttribute(",
                                MethodNames.toPropertyMethodSuffix(field.fieldName()),
                                entityTableTypeName,
                                converterFieldName);
                        addRowGetCode(methodBuilder, varName, field.sqlType().orElseThrow(), i[0]);
                        methodBuilder.addCode("));\n");
                    } else {
                        methodBuilder.addCode("entity.set$L(",
                                MethodNames.toPropertyMethodSuffix(field.fieldName()));
                        addRowGetCode(methodBuilder, varName, field.javaType(), i[0]);
                        methodBuilder.addCode(");\n");
                    }
                    ++i[0];
                });
    }

    private void addRowGetCode(MethodSpec.Builder methodBuilder, String varName, TypeMirror entityFieldType, int index) {
        var rowType = javaType2RowTypes.get(entityFieldType.toString());
        if (rowType == null) {
            methodBuilder.addCode("$L.get($T.class, $L)", varName, entityFieldType, index);
        } else {
            methodBuilder.addCode("$L.get$L($L)", varName, rowType, index);
        }
    }
}
