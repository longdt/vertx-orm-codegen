package com.github.longdt.vertxorm.codegen;

import com.squareup.javapoet.*;

import javax.annotation.processing.Filer;
import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.SourceVersion;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import java.io.IOException;
import java.util.function.Function;
import java.util.stream.Stream;

import static com.google.auto.common.GeneratedAnnotationSpecs.generatedAnnotationSpec;
import static com.squareup.javapoet.TypeSpec.interfaceBuilder;
import static javax.lang.model.element.Modifier.DEFAULT;
import static javax.lang.model.element.Modifier.PUBLIC;

public class ParametersMapperWriter {
    private final Filer filer;
    private final Elements elements;
    private final SourceVersion sourceVersion;
    private final Types types;

    ParametersMapperWriter(ProcessingEnvironment processingEnv) {
        this.filer = processingEnv.getFiler();
        this.elements = processingEnv.getElementUtils();
        this.sourceVersion = processingEnv.getSourceVersion();
        this.types = processingEnv.getTypeUtils();
    }

    void writeParametersMapper(EntityDeclaration entityDeclaration) throws IOException {
        String parametersMapperName = entityDeclaration.targetType().getSimpleName().toString() + Constant.PARAMETERS_MAPPER;
        TypeSpec.Builder factory =
                interfaceBuilder(parametersMapperName)
                        .addOriginatingElement(entityDeclaration.targetType());
        generatedAnnotationSpec(
                elements,
                sourceVersion,
                CodeGenProcessor.class,
                "Do not edit this file")
                .ifPresent(factory::addAnnotation);
        factory.addModifiers(PUBLIC);
        addSuperinterface(factory, entityDeclaration);
        var packageName = elements.getPackageOf(entityDeclaration.targetType()).getQualifiedName().toString();
        TypeSpecBuilders.addInterfaceInstanceField(factory, ClassName.get(packageName, parametersMapperName));
        addApplyMethod(factory, entityDeclaration);
        JavaFile.builder(packageName, factory.build())
                .skipJavaLangImports(true)
                .build()
                .writeTo(filer);
    }

    private void addApplyMethod(TypeSpec.Builder factory, EntityDeclaration entityDeclaration) {
        var entityTypeName = ClassName.get(entityDeclaration.targetType());
        var methodBuilder = MethodSpec.methodBuilder("apply")
                .addModifiers(DEFAULT, PUBLIC)
                .addAnnotation(Override.class)
                .addParameter(entityTypeName, "entity")
                .returns(ArrayTypeName.get(Object[].class))
                .addStatement("Object[] params = new Object[$L]", entityDeclaration.fieldsMap().size() + 1);
        addMappingStatements(methodBuilder, entityDeclaration);
        methodBuilder.addStatement("return params");
        factory.addMethod(methodBuilder.build());
    }

    private void addMappingStatements(MethodSpec.Builder methodBuilder, EntityDeclaration entityDeclaration) {
        var entityTableTypeName = ClassName.bestGuess(entityDeclaration.targetType().toString() + Constant.TABLE);
        int[] i = new int[1];
        entityDeclaration.fieldStream()
                .forEach(field -> {
                    if (field.converter().isPresent()) {
                        String converterFieldName = NamingStrategies.camelToScreamSnake(AnnotationHelper.getSimpleClassName(field.converter().get()));
                        methodBuilder.addStatement("params[$1L] = $2T.$3L.convertToDatabaseColumn(entity.get$4L())",
                                i[0],
                                entityTableTypeName,
                                converterFieldName,
                                MethodNames.toPropertyMethodSuffix(field.fieldName()));
                    } else {
                        methodBuilder.addStatement("params[$1L] = entity.get$2L()",
                                i[0],
                                MethodNames.toPropertyMethodSuffix(field.fieldName()));
                    }
                    ++i[0];
                });
    }

    private void addSuperinterface(TypeSpec.Builder factory, EntityDeclaration entityDeclaration) {
        factory.addSuperinterface(ParameterizedTypeName.get(
                ClassName.get(Function.class),
                ClassName.get(entityDeclaration.targetType()),
                ArrayTypeName.get(Object[].class)
        ));
    }
}
