package com.github.longdt.vertxorm.codegen;

import com.github.longdt.vertxorm.format.Case;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeSpec;

import javax.annotation.processing.Filer;
import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Modifier;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import java.io.IOException;
import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static com.google.auto.common.GeneratedAnnotationSpecs.generatedAnnotationSpec;
import static com.squareup.javapoet.TypeSpec.classBuilder;
import static javax.lang.model.element.Modifier.PUBLIC;

public class EntityTableWriter {
    private final Filer filer;
    private final Elements elements;
    private final SourceVersion sourceVersion;
    private final Types types;

    EntityTableWriter(ProcessingEnvironment processingEnv) {
        this.filer = processingEnv.getFiler();
        this.elements = processingEnv.getElementUtils();
        this.sourceVersion = processingEnv.getSourceVersion();
        this.types = processingEnv.getTypeUtils();
    }

    void writeColumns(EntityDeclaration entityDeclaration) throws IOException {
        String entityColumnsName = entityDeclaration.targetType().getSimpleName().toString() + Constant.TABLE;
        TypeSpec.Builder factory =
                classBuilder(entityColumnsName)
                        .addOriginatingElement(entityDeclaration.targetType());
        generatedAnnotationSpec(
                elements,
                sourceVersion,
                CodeGenProcessor.class,
                "Do not edit this file")
                .ifPresent(factory::addAnnotation);
        factory.addModifiers(PUBLIC);
        addTableNameField(factory, entityDeclaration);
        addColumnFields(factory, entityDeclaration);
        addConverterFields(factory, entityDeclaration);
        JavaFile.builder(elements.getPackageOf(entityDeclaration.targetType()).getQualifiedName().toString(), factory.build())
                .skipJavaLangImports(true)
                .build()
                .writeTo(filer);
    }

    private void addTableNameField(TypeSpec.Builder factory, EntityDeclaration entityDeclaration) {
        var namingStrategy = entityDeclaration.namingStrategy();
        String tableName = entityDeclaration.tableName();
        if (tableName.isEmpty()) {
            var entityName = entityDeclaration.targetType().getSimpleName().toString();
            tableName = NamingStrategies.resolveName(namingStrategy, entityName);
        }
        factory.addField(FieldSpec.builder(String.class, Constant.TABLE_NAME)
                .addModifiers(PUBLIC, Modifier.STATIC, Modifier.FINAL)
                .initializer("$S", tableName)
                .build());
    }

    private void addConverterFields(TypeSpec.Builder factory, EntityDeclaration entityDeclaration) {
        entityDeclaration.fieldStream()
                .flatMap(f -> f.converter().stream())
                .distinct()
                .forEach(tm -> {
                    String fieldName = NamingStrategies.camelToScreamSnake(AnnotationHelper.getSimpleClassName(tm));
                    TypeSpecBuilders.addConstantField(factory, tm, fieldName);
                });
    }

    private void addColumnFields(TypeSpec.Builder factory, EntityDeclaration entityDeclaration) {
        var namingStrategy = entityDeclaration.namingStrategy();
        var idFieldName = addColumnField(factory, namingStrategy, entityDeclaration.idField().fieldName(), entityDeclaration.idField().columnName().orElse(null));
        var otherFieldNames = addColumnFields(factory, namingStrategy, entityDeclaration.fieldsMap().values());
        addColumnNamesField(factory, idFieldName, otherFieldNames);
    }

    private String addColumnField(TypeSpec.Builder factory, Case namingStrategy, String attrName, String columnName) {
        var fieldName = NamingStrategies.camelToScreamSnake(attrName);
        factory.addField(
                FieldSpec.builder(String.class, fieldName)
                        .addModifiers(PUBLIC, Modifier.STATIC, Modifier.FINAL)
                        .initializer("$S", columnName == null ? NamingStrategies.resolveName(namingStrategy, attrName) : columnName)
                        .build());
        return fieldName;
    }

    private List<String> addColumnFields(TypeSpec.Builder factory, Case namingStrategy, Collection<FieldDeclaration> otherFields) {
        return otherFields.stream().map(fd -> addColumnField(factory, namingStrategy, fd.fieldName(), fd.columnName().orElse(null))).collect(Collectors.toList());
    }

    private void addColumnNamesField(TypeSpec.Builder factory, String idFieldName, Collection<String> otherFieldNames) {
        var fieldSpec = FieldSpec.builder(ParameterizedTypeName.get(List.class, String.class), Constant.COLUMN_NAMES)
                .addModifiers(PUBLIC, Modifier.STATIC, Modifier.FINAL)
                .initializer("$1T.of($2L)", List.class, Stream.concat(Stream.of(idFieldName), otherFieldNames.stream()).collect(Collectors.joining(", ")))
                .build();
        factory.addField(fieldSpec);
    }
}
